백엔드 프로그래밍: Node.js의 Koa 프레임워크
- 웹 애플리케이션을 만들 때는 리액트같은 프론트엔드 기술만으로 필요한 기능을 구현하는데는 한계가 있다.
- 데이터를 여러 사람과 공유하려면 저장할 공간이 필요하다.

[백엔드]
- 우리는 서버를 만들어 데이터를 여러 사람과 공유한다. 그런데 서버에 데이터를 무작정 담지 않는다. 데이터를 담을 때는
여러 가지 규칙이 필요하다.
- 예를 들어 특정 데이터를 등록할 때 사용자 인증 정보가 필요할 수 있고, 등록할 데이터를 어떻게 검증할지, 데이터의 종류가
다양하다면 어떻게 구분할지 등을 고려해야 한다.
- 데이터를 조회할 때도 마찬가지이다. 어떤 종류의 데이터를 몇 개씩 보여줄지, 그리고 또 어떻게 보여 줄지 등에
관한 로직을 만드는 것을 서버 프로그래밍 또는 백엔드 프로그래밍이라고 한다.
- 백엔드 프로그래밍은 여러 가지 환경으로 진행할 수 있다. 즉, 언어에 구애받지 않기 때문에 PHP, 파이썬, 자바, 자바스크립트, Golang,
루비 등과 같은 다양한 언어로 구현할 수 있다.
- 여기선 그중 자바스크립트로 서버를 구현할 수 있는 Node.js를 사용한다.

[Node.js]
- 처음에는 자바스크립트를 웹 브라우저에서만 사용했다. 속도가 그렇게 빠른 편은 아니었다.
- 시간이 지나면서 자바스크립트는 계속 발전해 왔으며, 구글이 크롬 웹 브라우저를 소개하면서 V8이라는 자바스크립트 엔진도
공개를 했다.
- 이 자바스크립트 엔진을 기반으로 웹 브라우저뿐만 아니라 서버에서도 자바스크립트를 사용할 수 있는 런타임을 개발했는데,
이것이 바로 Node.js이다.

[Koa]
- Node.js 환경에서 웹 서버를 구축할 때는 보통 Express, Hapi, Koa 등의 웹 프레임워크를 사용한다.
- Koa는 Express의 기존 개발 팀이 개발한 프레임워크이다. 기존 Express에서 고치고 싶었던 점들을 개선하면 내부 설계가
완전히 바뀌기 때문에 개발 팀이 아예 새로운 프레임워크를 개발했다고 한다.
- Express는 미들웨어, 라우팅, 템플릿, 파일 호스팅 등과 같은 다양한 기능이 자체적으로 내장되어 있는 반면, Koa는 미들웨어
기능만 갖추고 있으며 나머지는 다른 라이브러리를 적용하여 사용한다.
- 즉, Koa는 우리가 필요한 기능들만 붙여서 서버를 만들 수 있기 때문에 Express보다 훨씬 가볍다.
- 추가로 Koa는 async/await 문법을 정식으로 지원하기 때문에 비동기 작업을 더 편하게 관리할 수 있다.

작업 환경 준비
[package.json 파일 생성]
- 프로젝트의 버전, 설치된 라이브러리 정보, 라이센스 정보 등을 확인할 수 있다.
- yarn init -y

[koa 웹 프레임워크 설치]
- yarn add koa
- 설치 후 package.json 파일을 보면 dependencies 부분에 koa가 추가되어 있는 것을 확인할 수 있다.
"dependencies": {
    "eslint-config-prettier": "^8.3.0",
    "koa": "^2.13.1",
    "koa-bodyparser": "^4.3.0",
    "koa-router": "^10.0.0"
  },

[ESLint와 Prettier 설정]
- 서버 파일을 작성하기 전에 ESLint와 Prettier를 프로젝트에 적용한다.(자바스크립트 문법을 검사하고 깔끔한 코드를 작성하기 위해)
- 두 기능을 VS Code에서 사용하려면 VS Code 마켓플레이스에서 Prettier-Code-formatter와 ESLint 확장 프로그램을 설치해 둔 상태여야 한다.

- ESLint 설치
yarn add --dev eslint
yarn run eslint --init
? How would you like to use ESLint? To Check syntax and find problems
? What type of modules does your project use? CommonJS(require/exports)
? Which framework does your project use? None of these
? Where does your code run? Node (스페이스바를 통해 node 활성화)
? what format to you want your config file to be in? JSON

* --dev는 개발 모드에서만 사용한다는 것을 의미한다. 이렇게 설치하면 package.json에서 devDependencies부분에 추가 된다.
"devDependencies": {
    "eslint": "^7.28.0",
    "nodemon": "^2.0.7"
  },

- 이렇게 설정을 하고 나면 프로젝트 디렉토리에 ".eslintrc.json" 파일이 생성이 된다.

- Prettier 설정(.prettierrc)
{
    "singleQuote": true,
    "semi": true,
    "useTabs": false,
    "tabWidth": 2,
    "trailingComma": "all",
    "printWidth": 80
}

- Prettier에서 관리하는 코드 스타일은 ESLint에서 관리하지 않도록 eslint-config-prettier를 설치하여 적용한다.
yarn add eslint-config-prettier

- .eslintrc.json 수정
{
    "env": {
        "browser": true,
        "commonjs": true,
        "es2021": true,
        "node": true
    },
    "extends": ["eslint:recommended", "prettier"],
    "globals": {
        "Atomics": "readonly",
        "SharedArrayBuffer": "readonly"
    },
    "parserOptions": {
        "ecmaVersion": 12
    },
    // 오류에 따른 규칙을 변경할 수 있다.(추후 공부 필요!)
    "rules": {
        "no-unused-vars": "warn", // 변수 생성 후 사용하지 않을 때
        "no-console": "off" // console.log 사용할 때(기본적으로 ESlint에서는 console.log 사용을 지양하고 있다.)
    }
}

[nodemon 사용하기]
- 서버 코드를 변경할 때마다 서버를 재시작하는 것이 많이 번거롭다.
- nodemon이라는 도구를 사용하면 코드를 변경할 때마다 서버를 자동으로 재시작 해준다.
- 개발용 의존 모듈로 설치한다.
yarn add --dev nodemon
"devDependencies": {
    "eslint": "^7.28.0",
    "nodemon": "^2.0.7"
  }

- package.json에 scripts부분에 명령어를 추가한다.
"scripts": {
    "start": "node src", // 서버 실행 명령어
    "start:dev": "nodemon --watch src/ src/index.js" // nodemon을 통해 서버를 실행하는 명령
  }

- nodemon은 src 디렉토리를 주시하고 있다가 해당 디렉토리 내부의 어떤 파일이 변경되면, 이를 감지하여 src/index.js 파일을
재시작 해준다.
yarn start(재시작이 필요 없을 때 사용), yarn start:dev(재시작이 필요할 때 사용)

Koa 기본 사용법
[서버 띄우기]
- 서버를 여는 방법부터 알아보자

- src/index.js
const Koa = require('koa');

const app = new Koa();

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});

- 서버를 포트 4000번으로 열고, 서버에 접속하면 'hello world'라는 텍스트를 반환하도록 설정했다.
- node src 명령어를 통해 정상적으로 작동하는지 확인한다. (node를 통해 자바스크립트 파일을 실행할 때는 node src/index.js와 같이 전체 경로
를 입력하는 것이 맞지만, index.js 파일은 예외로 디렉토리까지만 입력해도 실행할 수 있음)

[미들웨어]
- koa 애플리케이션은 미들웨어의 배열로 구성되어 있다.
- app.use(미들웨어) 함수를 통해 미들웨어 함수를 애플리케이션에 등록한다.
- 미들웨어 함수는 다음과 같은 구조로 이루어져 있다.
(ctx, next) => {

}
- koa의 미들웨어 함수는 두 개의 파라미터를 받는다. 첫 번째 파라미터는 ctx라는 값이고, 두 번째 파라미터는 next이다.
- ctx는 Context의 줄임말로 웹 요청과 응답에 관한 정보를 지니고 있다. next는 현재 처리 중인 미들웨어의 다음 미들웨어를 호출하는
함수이다.
- 미들웨어를 등록하고 next 함수를 호출하지 않으면, 그 다음 미들웨어를 처리하지 않는다.
- 만약 미들웨어에서 next를 사용하지 않으면 ctx => {}와 같은 형태로 파라미터에 next를 생략해도 된다. 주로 다음 미들웨어를 처리할 필요가
없는 라우트 미들웨어를 나중에 설정할 때 이러한 구조로 next를 생략하여 미들웨어를 작성한다.
- 미들웨어는 app.use를 사용하여 등록한 순서대로 처리된다.
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url); //현재 요청받은 주소를 출력
  console.log(1);
  next();
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('4000 port');
});
- 만약 첫 번째 미들웨어에서 next 생략하면 다음 미들웨어들은 실행되지 않는다.

- 특정 조건일 때만 다음 미들웨어를 실행할 수 있게 설정하기
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url); //현재 요청받은 주소를 출력
  console.log(1);
  // http://localhost:4000/?authorized=1
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  next();
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('4000 port');
});
- 지금은 단순히 주소의 쿼리 파라미터를 사용하여 조건부로 처리했지만, 나중에는 웹 요청의 쿠키나 헤더를 통해 처리할 수도 있다.

[next함수는 Promise를 반환]
- next 함수를 호출하면 Promise를 반환한다. 이는 Koa가 Express와 차별화되는 부분이다.
- next 함수가 반환하는 Promise는 다음에 처리해야 할 미들웨어가 끝나야 완료된다.
- next 함수 호출 이후에 then을 사용하여 Promise가 끝난 다음 콘솔에 END를 기록하도록 수정해보자
const Koa = require('koa');

const app = new Koa();

app.use((ctx, next) => {
  console.log(ctx.url); //현재 요청받은 주소를 출력
  console.log(1);
  // http://localhost:4000/?authorized=1
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  next().then(() => {
    console.log('END'); // 다음 미들웨어가 끝난 후 실행 된다.
  });
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('4000 port');
});

[async/await 사용하기]
- Koa는 async/await를 정식으로 지원하기 때문에 해당 문법을 아주 편하게 사용할 수 있다.

* Express도 async/await 문법을 사용할 수 있지만, 오류를 처리하는 부분이 제대로 작동하지 않을 수 있다. 백엔드 개발을
하면서 예상치 못한 에러를 제대로 잡아내려면 express-async-errors라는 라이브러리를 따로 사용해야 한다.

- 기존 코드를 async/await를 사용하는 형태로 수정해보자
const Koa = require('koa');

const app = new Koa();

app.use(async (ctx, next) => {
  console.log(ctx.url); //현재 요청받은 주소를 출력
  console.log(1);
  // http://localhost:4000/?authorized=1
  if (ctx.query.authorized !== '1') {
    ctx.status = 401; // Unauthorized
    return;
  }
  await next();
  console.log('END');
});

app.use((ctx, next) => {
  console.log(2);
  next();
});

app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('4000 port');
});

koa-router 사용하기
- 앞에서 리액트를 배울 때 웹 브라우저의 라우팅을 돕는 리액트 라우터 라이브러리를 사용해 보았다.
- Koa를 사용할 때도 다른 주소로 요청이 들어올 경우 다른 작업을 처리할 수 있도록 라우터를 사용해야 한다.
- Koa 자체에 이 기능이 내장되어 있지는 않으므로, koa-router 모듈을 설치해야 한다.
yarn add koa-router

[기본 사용법]
- src/index.js
const Koa = require('koa');
const Router = require('koa-router');

const app = new Koa();
const router = new Router();

// 라우터 설정
router.get('/', (ctx) => {
  ctx.body = '홈';
});

router.get('/about', (ctx) => {
  ctx.body = '소개';
});

// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

app.listen(4000, () => {
  console.log('4000 port');
});
- koa-router를 불러온 뒤 이를 사용하여 Router 인스턴스를 만들었다.
- / 경로로 들어오면 '홈'을 띄우고, /about 경로로 들어오면 '소개' 텍스트가 나타나도록 설정했다.
- 라우트를 설정할 때, 첫 번째 파라미터에는 라우트의 경로를 넣고, 두 번째 파라미터에는 해당 라우터에 적용할 미들웨어 함수를
넣는다.
- router.get의 get 키워드는 해당 라우트에서 사용할 HTTP 메서드를 의미한다.(get 대신 post, put, delete 등을 넣을 수 있다.)

[라우트 파라미터와 쿼리]
- 이번에는 라우트의 파라미터와 쿼리를 읽는 방법을 알아보겠다.
- 라우터의 파라미터를 설정할 때는 /about/:name 형식으로 콜론(:)을 사용하여 라우트 경로를 설정한다.(리액트 라우터에서 설정
했을 때와 비슷하다.)
- 또 파라미터가 있을 수도 있고 없을 수도 있다면 /about/:name?같은 형식으로 파라미터 이름 뒤에 물음표를 사용한다.
- 이렇게 설정한 파라미터는 함수의 ctx.params 객체에서 조회할 수 있다.
- URL 쿼리의 경우, 예를 들어 /posts/?id=10 같은 형식으로 요청했다면 해당 값을 ctx.query에서 조회할 수 있다.
- 쿼리 문자열을 자동으로 객체 형태로 파싱해 주므로 별도로 파싱 함수를 돌릴 필요가 없다.(문자열 형태의 쿼리 문자열을 조회해야 할 때는
ctx.querystring을 사용한다.)

-src/index.js
const Koa = require('koa')
const Router = require('koa-router');

const app = new Koa();
const router = new Router();

router.get('/', (ctx) => {
  ctx.body = '홈';
});

router.get('/about/:name?', (ctx) => {
  const {name} = ctx.params;
  ctx.body = name ? `${name}`의 소개 : '소개';
});

router.get('/posts', (ctx) => {
  const {id} = ctx.query;
  ctx.body = id ? `포스트 #${id}` : '포스트 아이디가 없습니다.';
});

// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

app.listen(4000, () => {
  console.log('4000 port');
});
- 파라미터와 쿼리는 둘 다 주소를 통해 특정 값을 받아올 때 사용하지만, 용도가 서로 조금씩 다르다.
- 정해진 규칙은 따로 없지만, 일반적으로 파라미터는 처리할 작업의 카테고리를 받아 오거나, 고유 ID 혹은 이름으로
특정 데이터를 조회할 때 사용한다.
- 반면, 쿼리는 옵션에 관련된 정보를 받아온다. 예를 들어 여러 항목을 리스팅하는 API라면, 어떤 조건을 만족하는 항목을 보여 줄지
또는 어떤 기준으로 정렬할지를 정해야 할 때 쿼리를 사용한다.

[REST API]
나중에 따로 작성을 하자

[라우트 모듈화]
- 라우터를 여러 파일에 분리시켜서 작성하고, 이를 불러와 적용해보자

- src/api/index.js
const Router = require('koa-router');
const api = new Router();

api.get('/test', (ctx) => {
  ctx.body = 'test 성공';
});

module.exports = api;

- src/index.js
const Koa = require('koa');
const Router = require('koa-router');

const api = require(./api);

const app = new Koa();
cont router = new Router();

// 라우터 설정
router.use('/api', api.routes()); // api 라우트 적용

app.use(router.routes()).use(router.allowedMethods());

app.listen(4000, () => {
  console.log('4000 port');
});

[posts 라우트 생성]
- src/api/posts/index.js
const Router = require('koa-router');
const posts = new Router();

const printInfo = (ctx) => {
  ctx.body = {
    method: ctx.method,
    path: ctx.path,
    params: ctx.params,
  };
};

posts.get('/', printInfo);
posts.post('/', printInfo);
posts.get('/:id', printInfo);
posts.delete('/:id', printInfo);
posts.put('/:id', printInfo);
posts.patch('/:id', printInfo);
module.exports = posts;
- posts 라우터에 여러 종류의 라우트를 설정한 후 모두 printInfo 함수를 호출하도록 설정했다.

- 이후 api 라우트에 posts 라우트를 연결한다.
- src/api/index.js
const Router = require('koa-router');
const api = new Router();

const posts = require('./posts');

api.use('/posts', posts.routes());

module.exports = api;

- API 요청을 도와주는 Postman을 설치 후 사용해서 정상적으로 작동하는지 확인한다.(https://www.getpostman.com/)

[컨트롤러 파일 작성]
- 라우트 처리 함수만 모아 놓은 파일을 컨트롤러라고 한다.
- 지금은 아직 데이터베이스를 연결하지 않았으므로 자바스크립트의 배열 기능만 사용하여 API 기능을 구현해보자
- 구현하기 전 POST/PUT/PATCH 같은 메서드의 Reqeust Body에 JSON 형식으로 데이터를 넣어주면, 이를 파싱하여
서버에서 사용할 수 있게 해주는 koa-bodyparser를 설치한다.
yarn add koa-bodyparser

- src/index.js
const Koa = require('koa');
const Router = require('koa-router');
const bodyParser = require('koa-bodyparser');

const api = require('./api');

const app = new Koa();
const router = new Router();

router.use('/api', api.routes());

app.use(bodyParser()); // 반드시 router를 적용하는 코드의 윗부분에서 적용해야 한다.

// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

app.listen(4000, () => {
  console.log('Listening to port 4000');
});

- src/api/posts/posts.ctrl.js
let postId = 1; //id의 초깃값이다.

//posts 배열 초기 데이터
const posts = [
  {
    id: 1,
    title: '제목',
    body: '내용',
  },
];

/* 포스트 작성
POST /api/posts
{title, body}
*/
exports.write = (ctx) => {
  //REST API의 Request Body는 ctx.request.body에서 조회할 수 있다.
  const { title, body } = ctx.request.body;
  postId += 1;
  const post = { id: postId, title, body };
  posts.push(post);
  ctx.body = post;
};

/* 포스트 목록 조회
GET /api/posts
*/
exports.list = (ctx) => {
  ctx.body = posts;
};

/* 특정 포스트 조회
GET /api/posts/:id
*/
exports.read = (ctx) => {
  const { id } = ctx.params;
  //주어진 id 값으로 포스트를 찾습니다.
  //파라미터로 받아 온 값은 문자열 형식이므로 파라미터를 숫자로 변환하거나
  //비교할 p.id 값을 문자열로 변경해야 한다.
  const post = posts.find((p) => p.id.toString() === id);
  //포스트가 없으면 오류를 반환한다.
  if (!post) {
    ctx.status = 404;
    ctx.body = {
      message: '포스트가 존재하지 않습니다.',
    };
    return;
  }
  ctx.body = post;
};

/* 특정 포스트 제거
DELETE /api/posts/:id
*/
exports.remove = (ctx) => {
  const { id } = ctx.params;
  // 해당 id를 가진 post가 몇 번째 인지를 확인합니다.
  const index = posts.findIndex((p) => p.id.toString() === id);
  //포스트가 없으면 오류를 반환합니다.
  if (index === -1) {
    ctx.status = 404;
    ctx.body = {
      message: '포스트가 존재하지 않습니다.',
    };
    return;
  }
  //index번째 아이템을 제거합니다.
  posts.splice(index, 1);
  ctx.status = 204; //No Content
};

/* 포스트 수정(교체)
PUT /api/posts/:id
{title, body}
*/
exports.replace = (ctx) => {
  // PUT 메서드는 전체 포스트 정보를 입력하여 데이터를 통째로 교체할 때 사용한다.
  const { id } = ctx.params;
  // 해당 id를 가진 post가 몇 번째인지 확인한다.
  const index = posts.findIndex((p) => p.id.toString() === id);
  // 포스트가 없으면 오류를 반환한다.
  if (index === -1) {
    ctx.status = 404;
    ctx.body = {
      message: '포스트가 존재하지 않습니다.',
    };
    return;
  }
  // 전체 객제를 덮어 씌웁니다.
  // 따라서 id를 제외한 기존 정보를 날리고, 객체를 새로 만듭니다.
  posts[index] = {
    id,
    ...ctx.request.body,
  };
  ctx.body = posts[index];
};

/* 포스트 수정(특정 필드 변경)
PATCH /api/posts/:id
{title, body}
*/
exports.update = (ctx) => {
  //PATCH 메서드는 주어진 필드만 교체한다.
  const { id } = ctx.params;
  const index = posts.findIndex((p) => p.id.toString() === id);
  if (index === -1) {
    ctx.status = 404;
    ctx.body = {
      message: '포스트가 존재하지 않습니다.',
    };
    return;
  }
  posts[index] = {
    ...posts[index],
    ...ctx.request.body,
  };
  ctx.body = posts[index];
};

- src/api/posts/index.js
const Router = require('koa-router');
const postsCtrl = require('./posts.ctrl');

const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', postsCtrl.write);
posts.get('/:id', postsCtrl.read);
posts.delete('/:id', postsCtrl.remove);
posts.put('/:id', postsCtrl.replace);
posts.patch('/:id', postsCtrl.update);
module.exports = posts;

- put은 데이터 전체가 변경되기 때문에 사전에 Request body 부분에 누락된 필드가 없는지 확인하는 작업이 필요하다!(검증)

mongoose를 이용한 MongoDB 연동 실습
- Nodejs 서버와 MongoDB를 연동할 수 있도록 MongoDB 기초 지식을 알아본다.
- mongoose를 이용하여 서버에서 직접 데이터를 추가, 조회, 삭제, 수정하는 방법을 알아본다.

[SQL vs NoSQL]
- 서버를 개발할 때 데이터베이스를 사용하면 웹 서비스에서 사용되는 데이터를 저장하고, 효울적으로 조회하거나 수정할 수 있다.
- 기존에는 MySQL, OracleDB, PostgreSQL 같은 RDBMS(관계형 데이터베이스)를 자주 사용했다. 그런데 관계형 데이터베이스에는 몇 가지
한계가 있다.
- 첫 번째는 데이터 스키마가 고정적인 것이다. 여기서 스키마란 데이터베이스에 어떤 형식의 데이터를 넣을지에 대한 정보를 가리킨다.
- 예를 들어 회원 정보 스키마라면 계정명, 이메일, 이름 등이 해당된다. 새로 등록하는 데이터 형식이 기존에 있던 데이터들과 다르다면
기존 데이터를 모두 수정해야 새 데이터를 등록할 수 있다. 그래서 데이터양이 많을 때는 데이터베이스의 스키마를 변경하는 작업이
매우 번거로워질 수 있다.
- 두 번째는 확장성이다. RDBMS는 저장하고 처리해야 할 데이터양이 늘어나면 여러 컴퓨터에 분산시키는 것이 아니라, 해당 데이터베이스
서버의 성능을 업그레이드하는 방식으로 확장해 주어야 한다.
- MongoDB는 이런 한계를 극복한 문서 지향적 NoSQL 데이터베이스이다. 이 데이터베이스에 등록하는 데이터들은 유동적인 스키마를 지닐 수
있다.
- 종류가 같은 데이터라고 하더라도, 새로 등록해야 할 데이터 형식이 바뀐다고 하더라도 기존 데이터까지 수정할 필요가 없다.
- 서버의 데이터양이 늘어나도 한 컴퓨터에서만 처리하는 것이 아니라 여러 컴퓨터로 분산하여 처리할 수 있도록 확장하기 쉽게
설계되어 있다.
- MongoDB가 무조건 기존의 RDBMS보다 좋은 것은 아니다. 상황별로 적합한 데이터베이스가 다를 수 있다.
- 예를 들어 데이터의 구조가 자주 바뀐다면 MongoDB가 유리하다. 그러나 까다로운 조건으로 데이터를 필터링해야 하거나, ACID 특성을
지켜야 한다면 RDBMS가 더 유리할 수 있다.

* ACID 특성은 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)의 앞 글자를 따서 만든 용어로,
데이터베이스 트랜잭션이 안전하게 처리되는 것을 보장하기 위한 성질을 의미한다.
* 트랜잭션: 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할
일련의 연산들을 의미한다.

[문서란]
- 여기서 말하는 '문서(document)'는 RDBMS의 레코드(record, 행)와 개념이 비슷한다. 문서의 데이터 구조는 한 개 이상의
키-값 쌍으로 되어 있다.
{
  "_id": ObjectId("60d28a5b41e92243c8424df1"),
  "username": "Gyeongm1n",
  "name": {first: "g.m", last: "Park"}
}
- 문서는 BSON(바이너리 형태의 JSON) 형태로 저장된다. 그렇기 때문에 나중에 JSON 형태의 객체를 데이터베이스에 저장할 때,
큰 공수를 들이지 않고도 데이터를 데이터베이스에 등록할 수 있다.
- 새로운 문서를 만들면 _id라는 고윳값을 자동으로 생성하는데, 이 값은 시간, 머신 아이디, 프로세스 아이디, 순차 번호로 되어 있어
값의 고유함을 보장한다.
- 여러 문서가 들어 있는 곳을 컬렉션이라고 한다. 기존 RDBMS에서는 테이블 개념을 사용하므로 각 테이블마다 같은 스키마를 가지고 있어야 한다.
새로 등록해야 할 데이터가 다른 스키마를 가지고 있다면, 기존 데이터들의 스키마도 모두 바꾸어 주어야 한다.
- 반면, MongoDB는 다른 스키마를 가지고 있는 문서들이 한 컬렉션에서 공존할 수 있다.
{
  "_id": ObjectId("60d28a5b41e92243c8424df1"),
  "username": "Gyeongm1n",
}

{
  "_id": ObjectId("60d28a5b41e92243c8424df2"),
  "username": "Gyeongm1n",
  "name": {first: "g.m", last: "Park"}
}

[MongoDB 구조]
- 서버 하나에 데이터베이스를 여러 개 가지고 있을 수 있다. 각 데이터베이스에는 여러 개의 컬렉션이 있으며, 컬렉션 내부에는 문서들이
들어 있다.

[스키마 디자인]
- MongoDB에서 스키마를 디자인하는 방식은 기존 RDBMS에서 스키마를 디자인하는 방식과 완전히 다르다.
- RDBMS에서 블로그용 데이터 스키마를 설계한다면 각 포스트, 댓글마다 테이블을 만들어 필요에 따라 JOIN해서 사용하는 것이
일반적이다.(관계를 설정 -> 포스트는 여러개의 댓글을 갖고 유저는 여러개의 포스트를 갖는다.)
- 하지만 NoSQL에서는 그냥 모든 것을 문서 하나에 넣습니다.
{
  _id: ObjectId,
  title: String,
  body: String,
  username: String,
  createdDate: Date,
  comments: [
    {
      _id: ObjectId,
      text: String,
      createdDate: Date,
    },
  ],
};
- 댓글 문서를 포스트 문서 내부에 넣었는데 이처럼 문서 내부에 또 다른 문서가 위치하는 것을 서브다큐먼트라고 한다.
- 문서 하나에는 최대 16MB만큼 데이터를 넣을 수 있다. 만약 서브다큐먼트에서 이 용량을 초과할 가능성이 있다면 컬렉션을
분리시키는 것이 좋다.

MongoDB 서버 준비
- MongoDB, MongoDB Compass 설치(MongoDB의 GUI 프로그램) 설치
https://www.mongodb.com/download-center/community

- MongoDB 작동 확인
1. 내 컴퓨터의 몽고디비가 설치된 디렉토리로 이동(bin 디렉토리)
2. mongo 입력
3. version() 입력

mongoose의 설치 및 적용
- mongoose는 Node.js 환경에서 사용하는 MongoDB 기반 ODM(Object Data Modelling) 라이브러리이다.
- 이 라이브러리는 데이터베이스 문서들을 자바스크립트 객체처럼 사용할 수 있게 해준다.

yarn add mongoose dotenv

* dotenv는 환경변수들을 파일에 넣고 사용할 수 있게 하는 개발 도구이다. mongoose를 사용하여 MongoDB에 접속할 때,
서버에 주소나 계정 및 비밀번호가 필요할 경우도 있습니다. 이렇게 민감하거나 환경별로 달라질 수 있는 값은 코드 안에
직접 작성하지 않고, 환경변수로 설정하는 것이 좋습니다. 프로젝트를 깃허브 등의 서비스에 올릴 때는 .gitignore 파일을 작성하여
환경변수가 들어 있는 파일은 제외시켜 주어야 한다.

[.env 환경변수 파일 생성]
- blog/blog-backend/.env
PORT=4000
MONGO_URI=mongodb://localhost:27017/blog

- 여기서 blog는 우리가 사용할 데이터베이스 이름이다. 지정한 데이터베이스가 서버에 없다면 자동으로 만들어 주므로 사전에
직접 생성할 필요는 없다.

[mongoose로 서버와 데이터베이스 연결]
- src/main.js
require('dotenv').config(); // .env 파일의 값을 process.env를 통해 조회할 수 있음
import Koa from 'koa';
import Router from 'koa-router';
import bodyParser from 'koa-bodyparser';
import mongoose from 'mongoose';

import api from './api';

// 비구조화 할당을 통해 process.env 내부 값에 대한 레퍼런스 만들기
const { PORT, MONGO_URI } = process.env;

mongoose
  .connect(MONGO_URI, { useNewUrlParser: true, useFindAndModify: false })
  .then(() => {
    console.log('Connected to MongoDB');
  })
  .catch((e) => {
    console.error(e);
  });


const app = new Koa();
const router = new Router();

router.use('/api', api.routes());

app.use(bodyParser());

// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

// PORT가 지정되어 있지 않다면 4000을 사용
const port = PORT || 4000;
app.listen(port, () => {
  console.log('Listening to port %d', port);
});

esm으로 ES 모듈 import/export 문법 사용하기
- 기존 리액트 프로젝트에서 사용해 오던 ES 모듈 import/export 문법은 Node.js에서 아직 정식으로 지원되지 않는다.
- Node.js에 해당 기능이 구현되어 있기는 하지만 아직 실험적인 단계이기 때문에 기본 옵션으로는 사용할 수 없으며, 확장자를
.mjs로 사용하고 node를 실행할 때 --experimental-modules라는 옵션을 넣어 주어야 한다.
- Node.js에서 import/export 문법을 꼭 사용해야 할 필요는 없지만, 이 문법을 사용하면 VS Code에서 자동 완성을 통해 모듈을
자동으로 쉽게 불러올 수 있고 코드도 더욱 깔끔해진다.

[설치 및 적용]
yarn add esm

- 기존 src/index.js 파일의 이름을 main.js로 변경하고, index.js 파일을 새로 생성해서 다음 코드를 작성
// 이 파일에서만 no-global-assign ESLint 옵션을 비활성화합니다.
/* eslint-disable no-global-assign */

require = require('esm')(module /*, options*/);
module.exports = require('./main.js');

- package.json의 scripts 부분을 수정한다.
"scripts": {
    "start": "node -r esm src",
    "start:dev": "nodemon --watch src/ -r esm src/index.js"
  }

- ESLint에서 import/export 구문을 사용해도 오류로 간주하지 않도록 .eslintrc.json 수정(sourceType: "module")
{
    "env": {
        "browser": true,
        "commonjs": true,
        "es2021": true,
        "node": true
    },
    "extends": ["eslint:recommended", "prettier"],
    "globals": {
        "Atomics": "readonly",
        "SharedArrayBuffer": "readonly"
    },
    "parserOptions": {
        "ecmaVersion": 12,
        "sourceType": "module"
    },
    "rules": {
        "no-unused-vars": "warn",
        "no-console": "off"
    }
}

- 루트 디렉토리에 jsconfig.json 작성 (blog/blog-backend/jsconfig.json)
{
  // 자동 완성 기능 설정
    "compilerOptions": {
        "target": "es6",
        "module": "es2015"
    },
    "include": ["src/**/*"]
}

데이터베이스의 스키마와 모델
- mongoose에는 스키마와 모델이라는 개념이 있다.
- 스키마는 컬렉션에 들어가는 문서 내부의 각 필드가 어떤 형식으로 되어 있는지 정의하는 객체이다.
- 이와 달리 모델은 스키마를 사용하여 만드는 인스턴스로, 데이터베이스에서 실제 작업을 처리할 수 있는 함수들을
지니고 있는 객체이다.

[스키마 생성]
- 모델을 만들려면 사전에 스키마를 만들어 주어야 한다.
- 여기서는 블로그 포스트에 대한 스키마를 준비할 텐데, 어떤 데이터가 필요할지 한번 생각해 보자
- 제목(title, 문자열), 내용(body, 문자열), 태그(tags, 문자열 배열), 작성일(publishedDate, 날짜)
- 이렇게 네 가지 필드가 있는 스키마를 만들어 보자
- 나중에 유지 보수를 좀 더 수월하게 할 수 있도록 스키마와 모델에 관련된 코드는 src/models 디렉토리에 작성한다.

- src/models/post.js
import mongoose from 'mongoose';

const { Schema } = mongoose; // Schema 함수를 사용하여 스키마를 정의한다.

const PostSchema = new Schema({
  title: String,
  body: String,
  tags: [String], // 문자열로 이루어진 배열
  publishedDate: {
    type: Date,
    default: Date.now, // 현재 날짜를 기본값으로 지정
  },
});

[Schema에서 기본적으로 지원하는 타입]
String: 문자열
Number: 숫자
Date: 날짜
Buffer: 파일을 담을 수 있는 버퍼
Boolean: true 또는 false 값
Mixed(Schema.Types.Mixed): 어떤 데이터도 넣을 수 있는 형식
ObjectId(Schema.Types.ObjectId): 객체 아이디, 주로 다른 객체를 참조할 때 넣음
Array: 배열 형태의 값으로 []로 감싸서 사용

- 이 스키마를 활용하여 좀 더 복잡한 방식의 데이터도 저장할 수 있다.
const AuthorSchema = new Schema({
  name: String,
  email: String,
});

const BookSchena = new Schema({
  title: String,
  description: String,
  authors: [AuthorSchema],
  // AuthorSchema로 이루어진 여러 개의 객체가 들어 있는 배열을 의미
  // 이렇게 스키마 내부에 다른 스키마를 내장시킬 수도 있다.
  meta: {
    likes: Number,
  },
  extra: Schema.Types.Mixed
});

[모델 생성]
- mongoose.model 함수를 사용하여 모델을 만든다.

- src/models/post.js 수정
import mongoose from 'mongoose';

const { Schema } = mongoose;

const PostSchema = new Schema({
  title: String,
  body: String,
  tags: [String], // 문자열로 이루어진 배열
  publishedDate: {
    type: Date,
    default: Date.now, // 현재 날짜를 기본값으로 지정
  },
});

const Post = mongoose.model('Post', PostSchema);
export default Post; // 모델 인스턴스로 데이터베이스를 조작해야 되기 때문에 내보내준다.

- model() 함수는 기본적으로 두 개의 파라미터가 필요하다.
- 첫 번째 파라미터는 스키마 이름이고, 두 번째 파라미터는 스키마 객체이다.
- 데이터베이스는 스키마 이름을 정해 주면 그 이름의 복수 형태로 데이터베이스에 컬렉션 이름을 만든다.
ex) Post -> posts, BookInfo -> bookinfos
- MongoDB에서 컬렉션 이름을 만들 때, 권장되는 컨벤션(convention: 관습, 조약)은 구분자를 사용하지 않고 복수 형태로
사용하는 것이다.
- 이 컨벤션을 따르고 싶지 않다면, 다음 코드처럼 세 번째 파라미터에 원하는 이름을 입력하면 된다.
mongoose.model('Post', PostSchema, 'Post_Collection');
- 이 경우 첫 번째 파라미터로 넣어 준 이름은 나중에 다른 스키마에서 현재 스키마를 참조해야 하는 상황에서 사용한다.

데이터 관리
- src/api/posts/index.js
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';

const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', postsCtrl.write);
posts.get('/:id', postsCtrl.read);
posts.delete('/:id', postsCtrl.remove);
posts.patch('/:id', postsCtrl.update);

export default posts;

[데이터 생성]
- src/api/posts/posts.ctrl.js
/* 포스트 작성
POST /api/posts
{
  title: '제목',
  body: '내용'
  tags: ['태그1', '태그2']
}
*/
import Post from '../../models/post';

export const write = async (ctx) => {
  const { title, body, tags } = ctx.request.body;
  const post = new Post({
    title,
    body,
    tags,
  });
  try {
    await post.save();
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};
- 모델의 인스턴스를 만들 때는 new 키워드를 사용한다. 그리고 생성자 함수의 파라미터에 정보를 지닌 객체를 넣는다.
- 인스턴스를 만들면 바로 데이터베이스에 저장되는 것이 아니다. save() 함수를 실행시켜야 비로소 저장된다.

[데이터 조회]
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
import Post from '../../models/post';

export const list = async (ctx) => {
  try {
    const posts = await Post.find().exec();
    ctx.body = posts
  } catch (e) {
    ctx.throw(500, e);
  }
};

- find() 함수를 호출한 후에는 exec()를 붙여 주어야 서버에 쿼리를 요청한다.

[특정 데이터 조회]
- 특정 데이터를 id(ObjectId)로 찾아서 조회하는 기능을 구현한다.
- 특정 id를 가진 데이터를 조회할 때는 findById() 함수를 사용한다.
/* 특정 포스트 조회
GET /api/posts/:id
*/
import Post from '../../models/post';

export const read = async (ctx) => {
  const { id } = ctx.params;
  try {
    const post = await Post.findById(id).exec();
    if (!post) {
      ctx.status = 404; // Not Found
      return;
    }
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

- id 문자열을 몇 개 제거해서 ObjectId 형식을 파괴하면 서버 오류인 500 오류가 발생한다. 이는 전달받은 id가 ObjectId 형태가
아니서 발생하는 것이다.
- 이 부분은 서버 오류가 아닌 Bad Request 오류가 발생해야 하므로 추후 수정을 해줘야 한다.(검증 작업을 하는 미들웨어 추가)

[데이터 삭제]
- remove(): 특정 조건을 만족하는 데이터를 모두 지운다.
- findByIdAndRemove(): id를 찾아서 지운다.
- findOneAndRemove(): 특정 조건을 만족하는 데이터 하나를 찾아서 제거한다.

- src/api/posts/posts.ctrl.js
/* 포스트 삭제
DELETE /api/posts/:id
*/
import Post from '../../models/post';

export const remove = async (ctx) => {
  const { id } = ctx.params;
  try {
    await Post.findByIdAndRemove(id).exec();
    ctx.status = 204; // No Content
  } catch (e) {
    ctx.throw(500, e);
  }
};

[데이터 수정]
- 데이터를 업데이트할 때는 findByIdAndUpdate() 함수를 사용한다.
- 이 함수를 사용할 때는 세 가지 파라미터를 넣어 주어야 한다.(id, 업데이트 내용, 업데이트 옵션)
/* 포스트 수정
PATCH /api/posts/:id
{
  title: '수정',
  body: '수정 내용',
  tags: ['수정', '태그']
}
*/
export const update = async (ctx) => {
  const { id } = ctx.params;
  try {
    const post = await Post.findByIdAndUpdate(id, ctx.request.body, {
      new: true, //true일 때는 업데이트 된 내용, false일 때는 업데이트 되기 전에 내용을 반환
    }).exec();
    if (!post) {
      ctx.status = 404;
      return;
    }
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

요청 검증
[ObjectId 검증]
- 앞서 read API를 실행할 때, id가 올바른 ObjectId 형식이 아니면 500 오류가 발생했다. 500 오류는 보통 서버에서 처리하지
않아 내부적으로 문제가 생겼을 때 발생한다.
- 잘못된 id를 전달했다면 클라이언트가 요청을 잘못 보낸 것이니 400 Bad Request 오류를 띄워주는 것이 맞다.
- 그러려면 id 값이 올바른 ObjectId인지를 확인해야 하는데 이를 검증하는 방법은 다음과 같다.
import mongoose from 'mongoose';

const {ObjectId} = mongoose.Types;
ObjectId.isValid(id);

- id를 검증해주는 미들웨어를 작성한다.
- src/api/posts/posts.ctrl.js
import mongoose from 'mongoose';

const { ObjectId } = mongoose.Types;

export const checkObjectId = (ctx, next) => {
  const { id } = ctx.params;
  if (!ObjectId.isValid(id)) {
    ctx.status = 400; // Bad Request
    return;
  }
  return next();
};

- 라우트 중에서 ObjectId 검증이 필요한 라우트에 id를 검증해주는 미들웨어를 추가한다.
src/api/posts/index.js
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';

const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', postsCtrl.write);
posts.get('/:id', postsCtrl.checkObjectId, postsCtrl.read); // ObjectId를 검증해주는 미들웨어 추가
posts.delete('/:id', postsCtrl.checkObjectId, postsCtrl.remove);
posts.patch('/:id', postsCtrl.checkObjectId, postsCtrl.update);

export default posts;

- 만약 미들웨어를 추가하는 작업의 중복을 제거하고 싶다면 한 번 더 리팩토링 해준다.
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';

const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', postsCtrl.write);

const post = new Router();
post.get('/', postsCtrl.read); // ObjectId를 검증해주는 미들웨어 추가
post.delete('/', postsCtrl.remove);
post.patch('/', postsCtrl.update);

posts.use('/:id', postsCtrl.checkObjectId, post.routes());

export default posts

[Request Body 검증]
- API에서 전달받은 요청 내용을 검증하는 방법을 알아보자
- 포스트를 작성할 때 서버는 title, body, tags 값을 모두 전달받아야 한다. 그리고 클라이언트가 값을 빼먹었을 때
400 오류가 발생해야 한다.
- 객체를 검증하기 위해 각 값을 if 문으로 비교하는 방법도 있지만, 여기서는 이를 수월하게 해 주는 라이브러리인
Joi(https://github.com/hapijs/joi)를 설치하여 사용한다.
yarn add joi

- src/api/posts/posts.ctrl.js
import Joi from 'joi';

/* 포스트 작성
POST /api/posts
{
  title: '제목',
  body: '내용'
  tags: ['태그1', '태그2']
}
*/
export const write = async (ctx) => {
  const schema = Joi.object().keys({
    // 객체가 다음 필드를 가지고 있음을 검증
    title: Joi.string().required(), // required()가 있으면 필수 항목
    body: Joi.string().required(),
    tags: Joi.array().items(Joi.string()).required(), // 문자열로 이루어진 배열
  });
  // 검증하고 나서 검증 실패인 경우 에러 처리
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { title, body, tags } = ctx.request.body;
  const post = new Post({
    title,
    body,
    tags,
  });
  try {
    await post.save();
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

/* 포스트 수정
PATCH /api/posts/:id
{
  title: '수정',
  body: '수정 내용',
  tags: ['수정', '태그']
}
*/
export const update = async (ctx) => {
  const { id } = ctx.params;
  // write에서 사용한 schema와 비슷한데, required()가 없습니다.
  const schema = Joi.object().keys({
    title: Joi.string(),
    body: Joi.string(),
    tags: Joi.array().items(Joi.string()),
  });

  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400;
    ctx.body = result.error;
    return;
  }
  try {
    const post = await Post.findByIdAndUpdate(id, ctx.request.body, {
      new: true,
    }).exec();
    if (!post) {
      ctx.status = 404;
      return;
    }
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

페이지네이션 구현
- 데이터 목록이나 내용을 불러올 때 전부 다 불러올 필요는 없다. 따라서 제한적으로 불러오는 페이지네이션을 구현한다.

[가짜 데이터 생성하기]
- 페이지네이션 기능을 구현하려면 우선 충분한 데이터가 있어야 한다.
- 수작업으로 직접 등록을 해도 좋지만, 편하게 데이터를 채우기 위해 가짜 데이터를 생성하는 스크립트를 작성한다.

- src/createFakeData.js
import Post from './models/post'

export default function createFakeData() {
  // 0, 1, ..., 39로 이루어진 배열을 생성한 후 포스트 데이터로 변환
  const posts = [...Array(40).keys()].map(i => ({
    title: `포스트 #${i}`,
    // https://www.lipsum.com/에서 복사한 200자 이상의 텍스트
    body: `Lorem ipsum dolor sit amet, consectetur adipiscing elit, 
    sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, 
    quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 
    Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
    Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`,
    tags: ['가짜', '데이터'],
  }));
  Post.insertMany(posts, (err, docs) => {
    console.log(docs);
  })
}

- 그 다음 main.js의 데이터베이스를 서버와 연결하는 부분에 createFakeData 함수를 등록 후 한번만 실행한 뒤 지워준다.
(서버가 재실행될 때마다 가짜 데이터가 추가되는 걸 막기 위해)
- src/main.js
require('dotenv').config(); // .env 파일의 값을 process.env를 통해 조회할 수 있음
import Koa from 'koa';
import Router from 'koa-router';
import bodyParser from 'koa-bodyparser';
import mongoose from 'mongoose';

import api from './api';
import createFakeData from './createFakeData';

// 비구조화 할당을 통해 process.env 내부 값에 대한 레퍼런스 만들기
const { PORT, MONGO_URI } = process.env;

mongoose
  .connect(MONGO_URI, { useNewUrlParser: true, useFindAndModify: false })
  .then(() => {
    console.log('Connected to MongoDB');
    createFakeData(); // 한 번만 실행하고 지워준다.
  })
  .catch((e) => {
    console.error(e);
  });

const app = new Koa();
const router = new Router();

router.use('/api', api.routes());

app.use(bodyParser());

// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

// PORT가 지정되어 있지 않다면 4000을 사용
const port = PORT || 4000;
app.listen(port, () => {
  console.log('Listening to port %d', port);
});

[포스트 역순으로 불러오기]
- sort() 함수를 사용한다. sort 함수의 파라미터는 {key: 1} 형식이다. key는 정렬할 필드를 설정하는 부분이며, value 부분을
1로 설정하면 오름차순, -1로 설정하면 내림차순으로 정렬한다.
- _id를 내림차순으로 정렬하고 싶으니 {_id: -1}로 설정한다.
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  try {
    const posts = await Post.find().sort({_id: -1}).exec();
    ctx.body = posts
  } catch (e) {
    ctx.throw(500, e);
  }
};

[불러오는 개수 제한]
- 불러오는 개수를 제한할 때는 limit() 함수를 사용하고, 파라미터에는 제한할 숫자를 넣으면 된다.
- 예를 들어 데이터를 불러오는 개수를 열 개로 제한한다면 limit(10)이라고 설정하면 된다.
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  try {
    const posts = await Post.find().sort({_id: -1}).limit(10).exec();
    ctx.body = posts
  } catch (e) {
    ctx.throw(500, e);
  }
};

[페이지 기능 구현]
- 페이지 기능을 구현하려면 앞 절에서 배운 limit 함수를 사용해야 하고, 추가로 skip 함수도 사용해야 한다.
- skip 함수는 파라미터로 넣어준 값을 생략한다. 예를 들어 10을 넣어주면, 처음 열개의 데이터를 제외하고 그 다음 데이터를 불러온다.
- 그래서 페이지 기능을 구현하기 위해 skip 함수의 파라미터에 (page - 1) * 10을 넣어주면 된다.
1 -> 0개 생략, 2 -> 10 개 생략 ....
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 한다.
  // 값이 주어지지 않았다면 1을 기본으로 사용합니다.
  const page = parseInt(ctx.query.page || '1', 10);

  if (page < 1) {
    ctx.status = 400;
    return;
  }

  try {
    const posts = await Post.find().sort({_id: -1}).limit(10).skip((page - 1) * 10).exec();
    ctx.body = posts
  } catch (e) {
    ctx.throw(500, e);
  }
};

[마지막 페이지 번호 알려 주기]
- 마지막 페이지를 알 수 있다면 클라이언트가 더욱 편한다. (나중에 블로그 만들 때 뭔가 있을 듯..)
- 응답 내용의 형식을 바꾸어 새로운 필드를 설정하는 방법, Response 헤더 중 Link를 설정하는 방법, 커스텀 헤더를 설정하는 방법으로
이 정보를 알려줄 수 있다.

- 커스텀 헤더를 설정하여 마지막 페이지 번호를 클라이언트에게 알려주는 방법이다.
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 한다.
  // 값이 주어지지 않았다면 1을 기본으로 사용합니다.
  const page = parseInt(ctx.query.page || '1', 10);

  if (page < 1) {
    ctx.status = 400;
    return;
  }

  try {
    const posts = await Post.find().sort({_id: -1}).limit(10).skip((page - 1) * 10).exec();
    const postCount = await Post.countDocuments().exec();
    ctx.set('Last-Page', Math.ceil(postCount / 10));
  } catch (e) {
    ctx.throw(500, e);
  }
};

[내용 길이 제한]
- body의 길이가 200자 이상이면 뒤에 '...'을 붙이고 문자열을 자르는 기능을 구현해보자
- find()를 통해 조회한 데이터는 mongoose 문서 인스턴스의 형태이므로 데이터를 바로 변형할 수 없다.
- 그 대신 toJSON() 함수를 실행하여 JSON 형태로 변환한 뒤 필요한 변형을 일으켜 주어야 한다.
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 한다.
  // 값이 주어지지 않았다면 1을 기본으로 사용합니다.
  const page = parseInt(ctx.query.page || '1', 10);

  if (page < 1) {
    ctx.status = 400;
    return;
  }

  try {
    const posts = await Post.find().sort({_id: -1}).limit(10).skip((page - 1) * 10).exec();
    const postCount = await Post.countDocuments().exec();
    ctx.set('Last-Page', Math.ceil(postCount / 10));
    ctx.body = posts
      .map(post => post.toJSON())
      .map(post => ({
        ...post,
        body: post.body.length < 200 ? post.body : `${post.body.slice(0, 200)}...`,
      }));
  } catch (e) {
    ctx.throw(500, e);
  }
};

- 또 다른 방법으로 데이터를 조회할 때 lean() 함수를 사용하는 방법이 있다. 이 함수를 사용하면 데이터를 처음부터
JSON 형태로 조회할 수 있다.
- src/api/posts/posts.ctrl.js
/* 포스트 조회
GET /api/posts
*/
export const list = async (ctx) => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 한다.
  // 값이 주어지지 않았다면 1을 기본으로 사용합니다.
  const page = parseInt(ctx.query.page || '1', 10);

  if (page < 1) {
    ctx.status = 400;
    return;
  }

  try {
    const posts = await Post.find().sort({_id: -1}).limit(10).skip((page - 1) * 10).lean().exec();
    const postCount = await Post.countDocuments().exec();
    ctx.set('Last-Page', Math.ceil(postCount / 10));
    ctx.body = posts.map(post => ({
        ...post,
        body: post.body.length < 200 ? post.body : `${post.body.slice(0, 200)}...`,
      }));
  } catch (e) {
    ctx.throw(500, e);
  }
};

[추가]
MongDB: https://www.mongodb.com/
mongoose: https://mongoosejs.com/docs/guide.html

JWT를 통한 회원 인증 시스템 구현하기

JWT의 이해
- 우리가 만든 서버에 회원 인증 시스템을 구현하기 위해 JWT라는 기술을 사용한다.
- JWT는 JSON Web Token의 약자로, 데이터가 JSON으로 이루어져 있는 토큰을 의미한다.
- 두 개체가 서로 안전하게 정보를 주고받을 수 있도록 웹 표준으로 정의된 기술이다.

[세션 기반 인증과 토큰 기반 인증의 차이]
- 사용자의 로그인 상태를 서버에서 처리하는 데 사용할 수 있는 대표적인 두 가지 인증 방식이 있다.
- 하나는 세션을 기반으로 인증하는 것이고, 다른 하나는 토큰을 기반으로 인증하는 것이다.

[세션 기반 인증 시스템]
- 세션을 기반으로 인증 시스템을 만든다는 것은 서버가 사용자가 로그인 중임을 기억하고 있다는 뜻이다.
- 세션 기반 인증 시스템에서 사용자가 로그인을 하면, 서버는 세션 저장소에 사용자의 정보를 조회하고 세션 id를 발급한다.
- 발급된 id는 주로 브라우저의 쿠키에 저장한다.
- 그 다음에 사용자가 다른 요청을 보낼 때마다 서버는 세션 저장소에서 세션을 조회한 후 로그인 여부를 결정하여 작업을 처리하고
응답한다.
- 세션 저장소는 주로 메모리, 디스크, 데이터베이스 등을 사용한다.
- 세션 기반 인증의 단점은 서버를 확장하기가 번거러워질 수 있다는 점이다. 만약 서버의 인스턴스가 여러 개가 된다면, 모든 서버끼리
같은 세션을 공유해야 하므로 세션 전용 데이터베이스를 만들어야 할 뿐 아니라 신경 써야 할 것도 많아진다.
- 그렇다고 해서 세션 기반 인증이 무조건 좋지 않은 것은 아니다. 잘 설계하면 충분히 좋은 시스템이 될 수 있다.

[토큰 기반 인증 시스템]
- 토큰은 로그인 이후 서버가 만들어 주는 문자열이다. 해당 문자열 안에는 사용자의 로그인 정보가 들어 있고, 해당 정보가 서버에서
발급되었음을 증명하는 서명이 들어 있다.
- 서명 데이터는 해싱 알고리즘을 통해 만들어지는데, 주로 HMAC SHA256 혹은 RSA SHA256 알고리즘이 사용된다. (암호학과 관련 있는듯)
- 서버에서 만들어 준 토큰은 서명이 있기 때문에 무결성이 보장된다. 무결성이란 정보가 변경되거나 위조되지 않았음을 의미하는 성질이다.
- 사용자가 로그인을 하면 서버에서 사용자에게 해당 사용자의 정보를 지니고 있는 토큰을 발급해 주고, 추후 사용자가 다른 API를 요청하게
될 때 발급받은 토큰과 함께 요청을 하게 된다.
- 그러면 서버는 해당 토큰이 유효한지 검사하고, 결과에 따라 작업을 처리하고 응답한다.
- 토큰 기반 인증 시스템의 장점은 서버에서 사용자 로그인 정보를 기억하기 위해 사용하는 리소스가 적다는 점이다.
- 사용자 쪽에서 로그인 상태를 지닌 토큰을 가지고 있으므로 서버의 확장성이 매우 높다. 서버의 인스턴스가 여러 개로 늘어나도 서버끼리
사용자의 로그인 상태를 공유하고 있을 필요가 없다.

User 스키마/모델 만들기
- User 스키마와 모델을 작성하여 사용자의 정보를 MongoDB에 저장하고 조회한다. 현재 프로젝트의 사용자 스키마에는 사용자 계정명과
비밀번호가 필요하다.
- 비밀번호를 데이터베이스에 저장할 때 플레인(아무런 가공도 하지 않은) 텍스트로 저장하면 보안상 매우 위험하다. 따라서 단방향
해싱 함수를 지원해 주는 bcrypt 라이브러리를 설치해 사용하여 비밀번호를 안전하게 저장한다.
yarn add bcrypt

- 우선 src/models/user.js 파일을 생성하고 스키마와 모델을 작성한다.
import mongoose, { Schema } from 'mongoose';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});

const User = mongoose.model('User', UserSchema);
export default User;

[모델 메서드 만들기]
- 모델 메서드는 모델에서 사용할 수 있는 함수를 의미하며, 두 가지 종류가 있다.
- 첫 번째는 인스턴스 메서드로, 모델를 통해 만든 문서 인스턴스에서 사용할 수 있는 함수를 의미한다.
const user = new User({username: 'Gyeongm1n'});
user.setPassword('asdfasdf12');
- 두 번째는 스태틱(static) 메서드로, 모델에서 바로 사용할 수 있는 함수를 의미한다.
const user = User.findByUsername('Gyeongm1n');

[인스턴스 메서드 만들기]
- 두 개의 인스턴스 메서드를 만들어 보자
- 첫 번째 메서드는 setPassword이다. 이 메서드를 통해 비밀번호를 파라미터로 받아서 계정의 hashedPassword 값을 설정해준다.
- 두 번째 메서드는 checkPassword이다. 이 메서드는 파라미터로 받은 비밀번호가 해당 계정의 비밀번호와 일치하는지 검증해준다.
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcrypt';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});

// 화살표 함수의 this는 상위 스코프의 this와 같다
// 일반 함수의 this는 동적으로 바인딩된다.

// 인스턴스 매서드
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10); // 두번 째 파라미터는 해쉬 횟수
  this.hashedPassword = hash;
};

UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result; // true or false
};

const User = mongoose.model('User', UserSchema);
export default User;

- 인스턴스 메서드를 작성할 때는 화살표 함수가 아닌 function 키워드를 사용하여 구현해야 한다.
- 함수 내부에서 this에 접근해야 하기 때문인데, 여기서 this는 문서 인스턴스를 가리킨다. 그러나 화살표 함수를 사용하면
this는 문서 인스턴스를 가리키지 못한다. (화살표 함수의 this는 상위 스코프의 this와 같기 때문)

[스태틱 메서드 만들기]
- username으로 데이터를 찾을 수 있게 해주는 findByUsername 스태틱 함수를 작성한다.
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcrypt';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});

// 화살표 함수의 this는 상위 스코프의 this와 같다
// 일반 함수의 this는 동적으로 바인딩된다.

// 인스턴스 매서드
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10);
  this.hashedPassword = hash;
};

UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result; // true or false
};

// 스태틱 매서드
UserSchema.statics.findByUsername = function (username) {
  return this.findOne({ username });
};

const User = mongoose.model('User', UserSchema);
export default User;

- 스태틱 메서드에서 this는 모델을 가리킨다. 그러므로 여기서는 User를 가리킨다.

회원 인증 API 만들기
- 이제 회원 인증 API 만든다.
- src/api/auth/auth.ctrl.js
export const register = async (ctx) => {
  // 회원가입
}
export const login = async (ctx) => {
  // 로그인
}
export const check = async (ctx) => {
  // 로그인 상태 확인
}
export const logout = async (ctx) => {
  // 로그아웃
}
- 이렇게 auth 라우터에는 총 4개의 api가 존재한다.
- 라우터의 구조를 설정한다.
- src/api/auth/index.js
import Router from 'koa-router';
import * as authCtrl from './auth.ctrl';

const auth = new Router();

auth.post('/register', authCtrl.register);
auth.post('/login', authCtrl.login);
auth.get('/check', authCtrl.check);
auth.post('/logout', authCtrl.logout);

export default auth;

- src/api/index.js
import Router from 'koa-router';
import posts from './posts';
import auth from './auth';

const api = new Router();

api.use('/posts', posts.routes());
api.use('/auth', auth.routes());

// 라우터를 내보냅니다.
export default api;

[회원가입 구현하기]
- src/api/auth/auth.ctrl.js
import Joi from 'joi';
import User from '../../models/user';

/*회원가입
POST /api/auth/register
{
  username: 'Gyeongm1n'
  password: 'asdfasdf12'
}
*/
export const register = async (ctx) => {
  // Request Body 검증하기
  const schema = Joi.object().keys({
    username: Joi.string()
      .alphanum() // only a-z, A-Z, 0-9, Joi 문서 확인해보면 이것 외에도 email 등등 있음
      .min(3)
      .max(20)
      .required(),
    password: Joi.string().required(),
  });
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { username, password } = ctx.request.body;
  try {
    // username이 이미 존재하는지 확인
    const exists = await User.findByUsername(username);
    if (exists) {
      ctx.status = 409; // Conflict
      return;
    }

    const user = new User({
      username,
    });
    await user.setPassword(password); // 비밀번호 설정
    await user.save(); // 데이터베이스에 저장

    // 응답할 데이터에서 hashedPassword 필드 제거
    const data = user.toJSON();
    delete data.hashedPassword;
    ctx.body = data;
  } catch (e) {
    ctx.throw(500, e);
  }
};
- 회원가입을 할 때 중복되는 계정이 생성되지 않도록 기존에 해당 username이 존재하는지 확인한다. 이 작업은 findByUsername 스태틱 메서드를 
사용해 처리했다.
- 그리고 비밀번호를 설정하는 과정에서는 setPassword 인스턴스 함수를 사용했다.
- 이렇게 스태틱 또는 인스턴스 함수에서 해야 하는 작업들은 이 API 함수 내부에서 직접 구현해도 상관없지만, 이렇게 메서드들을 만들어서
사용하면 가독성도 좋고 유지 보수를 할 때도 도움이 된다.
- 함수의 마지막 부분에서는 hashedPassword 필드가 응답되지 않도록 데이터를 JSON으로 변환한 후 delete를 통해 해당 필드를 지워 주었는데,
앞으로 비슷한 작업을 자주 하게 될 것이므로 이 작업을 serialize라는 인스턴스 함수로 따로 만들어 준다.
- src/models/user.js
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcrypt';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});

// 화살표 함수의 this는 상위 스코프의 this와 같다
// 일반 함수의 this는 동적으로 바인딩된다.

// 인스턴스 매서드
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10);
  this.hashedPassword = hash;
};

UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result; // true or false
};

UserSchema.methods.serialize = function () {
  const data = this.toJSON();
  delete data.hashedPassword;
  return data;
};

// 스태틱 매서드
UserSchema.statics.findByUsername = function (username) {
  return this.findOne({ username });
};

const User = mongoose.model('User', UserSchema);
export default User;

- src/api/auth/auth.ctrl.js
import Joi from 'joi';
import User from '../../models/user';

/*회원가입
POST /api/auth/register
{
  username: 'Gyeongm1n'
  password: 'asdfasdf12'
}
*/
export const register = async (ctx) => {
  // Request Body 검증하기
  const schema = Joi.object().keys({
    username: Joi.string()
      .alphanum() // only a-z, A-Z, 0-9, Joi 문서 확인해보면 이것 외에도 email 등등 있음
      .min(3)
      .max(20)
      .required(),
    password: Joi.string().required(),
  });
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { username, password } = ctx.request.body;
  try {
    // username이 이미 존재하는지 확인
    const exists = await User.findByUsername(username);
    if (exists) {
      ctx.status = 409; // Conflict
      return;
    }

    const user = new User({
      username,
    });
    await user.setPassword(password); // 비밀번호 설정
    await user.save(); // 데이터베이스에 저장

    // 응답할 데이터에서 hashedPassword 필드 제거
    ctx.body = user.serialize();
  } catch (e) {
    ctx.throw(500, e);
  }
};

[로그인 구현하기]
- src/api/auth/auth.ctrl.js
import Joi from 'joi';
import User from '../../models/user';

/*로그인
POST /api/auth/login
{
  username: 'Gyeongm1n'
  password: 'asdfasdf12'
}
*/
export const login = async (ctx) => {
  const { username, password } = ctx.request.body;

  // username, password가 없으면 에러 처리
  if (!username || !password) {
    ctx.status = 401; // Unauthorized
    return;
  }

  try {
    const user = await User.findByUsername(username);
    // 계정이 존재하지 않으면 에러 처리
    if (!user) {
      ctx.status = 401;
      return;
    }
    const valid = await user.checkPassword(password);
    // 잘못된 비밀번호
    if (!valid) {
      ctx.status = 401;
      return;
    }
    ctx.body = user.serialize();
  } catch (e) {
    ctx.throw(500, e);
  }
};
- 이 API에서는 username, password 값이 제대로 전달되지 않으면 에러로 처리된다. 그리고 findByUsername을 통해 사용자 데이터를 찾고,
만약 사용자 데이터가 없으면 역시 에러로 처리한다.
- 계정이 유효하다면 checkPassword를 통해 비밀번호를 검사하고 성공했을 때는 계정 정보를 응답한다.

토큰 발급 및 검증하기
- 클라이언트에서 사용자 로그인 정보를 지니고 있을 수 있도록 서버에서 토큰을 발급해줘야 한다.
- JWT 토큰을 만들기 위해서는 jsonwebtoken이라는 모듈을 설치해야 한다.
yarn add jsonwebtoken

[비밀키 설정하기]
- .env 파일을 열어서 JWT 토큰을 만들 때 사용할 비밀키를 만든다. 이 비밀키는 문자열로 아무거나 입력하면 된다. (길이도 자유!)
PORT=4000
MONGO_URI=mongodb://localhost:27017/blog
JWT_SECRET=v4c2ahi6lu96ehyqkkmmn1a7srppq3qaqqgacwthonysp3mrcql7nt5ib85ie84vaxsz11jdf8a8go8
fzgl5t3xeeadk3a5u0zyae0qw0apkct1vl8z5dyljd3f04i8nlj08sk4bj3e8lxjv8otrp2

- 비밀키는 나중에 JWT 토큰의 서명을 만드는 과정에서 사용된다.
- 비밀키는 외부에 공개되면 절대로 안된다. 비밀키가 공개되는 순간, 누구든지 마음대로 JWT 토큰을 발급할 수 있기 때문이다.

[토큰 발급하기]
- user 모델 파일에서 generateToken 인스턴스 만들기
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});

// 화살표 함수의 this는 상위 스코프의 this와 같다
// 일반 함수의 this는 동적으로 바인딩된다.

// 인스턴스 매서드
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10);
  this.hashedPassword = hash;
};

UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result; // true or false
};

UserSchema.methods.serialize = function () {
  const data = this.toJSON();
  delete data.hashedPassword;
  return data;
};

UserSchema.methods.generateToken = function () {
  const token = jwt.sign(
    // 첫 번째 파리미터에는 토큰 안에 집어넣고 싶은 데이터를 넣는다.
    {
      _id: this.id,
      username: this.username,
    },
    process.env.JWT_SECRET, // 두 번째 파라미터에는 JWT 암호를 넣는다.
    {
      expiresIn: '7d', // 7일 동안 유효함
    },
  );
  return token;
};

// 스태틱 매서드
UserSchema.statics.findByUsername = function (username) {
  return this.findOne({ username });
};

const User = mongoose.model('User', UserSchema);
export default User;

- 회원가입과 로그인에 성공했을 때 토큰을 사용자에게 전달하며 사용자가 브라우저에서 토큰을 사용할 때는 주로 두 가지 방법을
사용한다.
- 첫 번째는 브라우저의 localStorage 혹은 sessionStorage에 담아서 사용하는 방법이고, 두 번째는 브라우저의 쿠키에 담아서 사용하는
방법이다.
- 브라우저의 localStorage 혹은 sessionStorage에 토큰을 담으면 사용하기가 매우 편리하고 구현하기도 쉽다. 하지만 만약 누군가가 페이지에
악성 스크립트를 삽입한다면 쉽게 토큰을 탈취할 수 있다. (이러한 공격을 XSS:Cross Site Scripting라고 한다.)
- 쿠키에 담아도 같은 문제가 발생할 수 있지만, httpOnly라는 속성을 활성화하면 자바스크립트를 통해 쿠키를 조회할 수 없으므로 악성
스크립트로부터 안전하다.
- 그 대신 CSRF(Cross Site Request Forgery)라는 공격에 취약해질 수 있다. 이 공격은 토큰을 쿠키에 담으면 사용자가 서버로 요청을
할 때마다 무조건 토큰이 함께 전달되는 점을 이용해서 사용자가 모르게 원하지 않는 API 요청을 하게 만든다.
- 예를 들어 사용자가 자신도 모르는 상황에서 어떠한 글을 작성하거나 삭제하거나, 또는 탈퇴하게 만들 수 있다.
- 단, CSRF는 CSRF 토큰 사용 및 Referer 검증 등의 방식으로 제대로 막을 수 있는 반면, XSS는 보안장치를 적용해 놓아도 개발자가 놓칠 수
있는 다양한 취약점을 통해 공격을 받을 수 있다.
- 여기서는 사용자 토큰을 쿠키에 담아서 사용한다.

- src/api/auth/auth.ctrl.js
import Joi from 'joi';
import User from '../../models/user';

/*회원가입
POST /api/auth/register
{
  username: 'Gyeongm1n'
  password: 'asdfasdf12'
}
*/
export const register = async (ctx) => {
  // Request Body 검증하기
  const schema = Joi.object().keys({
    username: Joi.string()
      .alphanum() // only a-z, A-Z, 0-9, Joi 문서 확인해보면 이것 외에도 email 등등 있음
      .min(3)
      .max(20)
      .required(),
    password: Joi.string().required(),
  });
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { username, password } = ctx.request.body;
  try {
    // username이 이미 존재하는지 확인
    const exists = await User.findByUsername(username);
    if (exists) {
      ctx.status = 409; // Conflict
      return;
    }

    const user = new User({
      username,
    });
    await user.setPassword(password); // 비밀번호 설정
    await user.save(); // 데이터베이스에 저장

    // 응답할 데이터에서 hashedPassword 필드 제거
    ctx.body = user.serialize();

    const token = user.generateToken();
    ctx.cookies.set('access_token', token, {
      maxAge: 1000 * 60 * 60 * 24 * 7, // 7일
      httpOnly: true,
    });
  } catch (e) {
    ctx.throw(500, e);
  }
};

/*로그인
POST /api/auth/login
{
  username: 'Gyeongm1n'
  password: 'asdfasdf12'
}
*/
export const login = async (ctx) => {
  const { username, password } = ctx.request.body;

  // username, password가 없으면 에러 처리
  if (!username || !password) {
    ctx.status = 401; // Unauthorized
    return;
  }

  try {
    const user = await User.findByUsername(username);
    // 계정이 존재하지 않으면 에러 처리
    if (!user) {
      ctx.status = 401;
      return;
    }
    const valid = await user.checkPassword(password);
    // 잘못된 비밀번호
    if (!valid) {
      ctx.status = 401;
      return;
    }
    ctx.body = user.serialize();
    const token = user.generateToken();
    ctx.cookies.set('access_token', token, {
      maxAge: 1000 * 60 * 60 * 24 * 7, // 7일
      httpOnly: true,
    });
  } catch (e) {
    ctx.throw(500, e);
  }
};

[토큰 검증하기]
- 사용자의 토큰을 확인한 후 검증하는 작업을 미들웨어를 통해 처리한다.

- src/lib/jwtMiddleware.js
import jwt from 'jsonwebtoken';
import User from '../models/user';

const jwtMiddleware = async (ctx, next) => {
  const token = ctx.cookies.get('access_token');
  if (!token) return next(); // 토큰이 없음
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log(decoded);
    return next();
  } catch (e) {
    // 토큰 검증 실패
    return next();
  }
};

export default jwtMiddleware;

- 미들웨어를 만든 뒤 main.js에서 app에 미들웨어를 적용한다. jwtMiddleware를 적용하는 작업은 app에 router 미들웨어를 적용하기
전에 이루어져야 한다. (즉, 코드가 더욱 상단에 위치해야 한다.)
- src/main.js
require('dotenv').config(); // .env 파일의 값을 process.env를 통해 조회할 수 있음
import Koa from 'koa';
import Router from 'koa-router';
import bodyParser from 'koa-bodyparser';
import mongoose from 'mongoose';

import api from './api';
import jwtMiddleware from './lib/jwtMiddleware';

// 비구조화 할당을 통해 process.env 내부 값에 대한 레퍼런스 만들기
const { PORT, MONGO_URI } = process.env;

mongoose
  .connect(MONGO_URI, { useNewUrlParser: true, useFindAndModify: false })
  .then(() => {
    console.log('Connected to MongoDB');
  })
  .catch((e) => {
    console.error(e);
  });

const app = new Koa();
const router = new Router();

router.use('/api', api.routes());

app.use(bodyParser());
app.use(jwtMiddleware);
// app 인스턴스에 라우터 적용
app.use(router.routes()).use(router.allowedMethods());

// PORT가 지정되어 있지 않다면 4000을 사용
const port = PORT || 4000;
app.listen(port, () => {
  console.log('Listening to port %d', port);
});

- 이렇게 하고 서버를 실행하면 토큰이 존재할 때 토큰에 대한 정보가 콘솔창에 출력된다. 토큰에 대한 정보를 다른 미들웨어에서
사용할 수 있게 하려면 ctx의 state 안에 넣어주면 된다.
- src/lib/jwtMiddleware.js
import jwt from 'jsonwebtoken';
import User from '../models/user';

const jwtMiddleware = async (ctx, next) => {
  const token = ctx.cookies.get('access_token');
  if (!token) return next(); // 토큰이 없음
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log(decoded);
    ctx.state.user = {
      _id: decoded._id,
      username: decoded.username,
    };
    return next();
  } catch (e) {
    // 토큰 검증 실패
    return next();
  }
};

export default jwtMiddleware;

- ctx.state의 user 값을 활용하여 check 컨트롤러 함수를 구현한다.
- src/api/auth/auth.ctrl.js
export const check = async (ctx) => {
  const { user } = ctx.state;
  if (!user) {
    // 로그인 중 아님
    // 근데 현재 소스코드 상태에서는 회원가입을 하고 이 컨트롤러 함수를 실행해도 정상적으로 동작함
    ctx.status = 401; // Unauthorized
    return;
  }
  ctx.body = user;
};

[토큰 재발급하기]
- jwt.verify() 함수를 통해 받아오는 decoded 객체에는 토큰이 언제 만들어졌는지 알려주는 iat 값과 언제 만료되는지 알려주는 exp 값이
들어있다.
- 이를 이용해서 현재 토큰의 유효 기간이 3.5일 미만일 때 새로운 토큰을 재발급해 주는 기능을 구현한다.
- src/lib/jwtMiddleware.js
import jwt from 'jsonwebtoken';
import User from '../models/user';

const jwtMiddleware = async (ctx, next) => {
  const token = ctx.cookies.get('access_token');
  if (!token) return next(); // 토큰이 없음
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    ctx.state.user = {
      _id: decoded._id,
      username: decoded.username,
    };
    // 토큰의 남은 유효 기간이 3.5일 미만이면 재발급
    const now = Math.floor(Date.now() / 1000);
    if (decoded.exp - now < 60 * 60 * 24 * 3.5) {
      console.log('재발급');
      const user = await User.findById(decoded._id);
      const token = user.generateToken();
      ctx.cookies.set('access_token', token, {
        maxAge: 1000 * 60 * 60 * 24 * 7, // 7일
        httpOnly: true,
      });
    }
    return next();
  } catch (e) {
    // 토큰 검증 실패
    return next();
  }
};

export default jwtMiddleware;
*  Date.now은 1970년 1월 1일 0시 0분 0초부터 현재까지 경과된 시간을 밀리 초를 반환
* 이를 1000으로 나누어주면 초 단위로 변환됨 (1초 -> 1000밀리초)
* decoded 객체에는 iat(생성시간), exp(만료시간)이 있음, 토큰 유효 기간을 7일로 두면 실제로 두 시간의 차를 순서대로
분(/60), 시(/60), 하루(/24)로 나누면 7이 나오는 걸 확인할 수 있다.

- 토큰 재발급이 잘되는지 확인해 보고 싶다면 user 모델 파일의 generateToken 함수에서 토큰 유효 기간을 3일로 설정하고,
login API 요청 후 check API 요청을 해서 재발급이 되는지 확인한다.

[로그아웃 기능 구현하기]
- 로그아웃 API는 쿠키를 지워 주기만 하면 구현할 수 있어 매우 간단하다.
- src/api/auth/auth.ctrl.js
/*
POST /api/auth/logout
*/
export const logout = async (ctx) => {
  ctx.cookies.set('access_token');
  ctx.status = 204; // No Content
};

posts API에 회원 인증 시스템 도입하기
- 새 포스트는 이제 로그인해야만 작성할 수 있고, 삭제와 수정은 작성자만 할 수 있도록 구현한다.
- 각각의 함수를 직접 수정해서 이 기능을 구현해도 되지만, 여기서는 미들웨어는 만들어서 관리한다.
- 또한, 각 포스트를 어떤 사용자가 작성했는지 알아야 하기 때문에 기존의 Post 스키마를 수정해줘야 한다.

[스키마 수정하기]
- 보통 관계형 데이터베이스에서는 데이터의 id만 관계 있는 데이터에 넣어 주는 반면, MongoDB에서는 필요한 데이터를 통째로 집어
넣는다. Post 스키마 안에 사용자의 id와 username을 전부 넣어 주어야 한다.
- src/models/post.js
import mongoose from 'mongoose';

const { Schema } = mongoose;

const PostSchema = new Schema({
  title: String,
  body: String,
  tags: [String], // 문자열로 이루어진 배열
  publishedDate: {
    type: Date,
    default: Date.now, // 현재 날짜를 기본값으로 지정
  },
  user: {
    _id: mongoose.Types.ObjectId,
    username: String,
  },
});

const Post = mongoose.model('Post', PostSchema);
export default Post;
- 스키마를 수정한 후 기존 posts 컬렉션에 있던 데이터들을 모두 삭제한다. (기존 데이터에는 작성자 정보가 없음)

[로그인했을 때만 API를 사용할 수 있게 하기]
- checkLoggedIn이라는 미들웨어를 만들어서 로그인해야만 글쓰기, 수정, 삭제를 할 수 있도록 구현한다.
- src/lib/checkLoggedIn.js
const checkLoggedIn = (ctx, next) => {
  if (!ctx.state.user) {
    ctx.status = 401; // Unauthorized
    return;
  }
  return next();
};

export default checkLoggedIn;
- 이 미들웨어는 로그인 상태가 아니라면 401 HTTP Status를 반환하고, 그렇지 않으면 다음 미들웨어를 실행한다.
- 이 미들웨어를 posts 라우터에 적용한다.
- src/api/posts/index.js
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';
import checkLoggedIn from '../../lib/checkLoggedIn';
const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', checkLoggedIn, postsCtrl.write);
posts.get('/:id', postsCtrl.checkObjectId, postsCtrl.read); // ObjectId를 검증해주는 미들웨어 추가
posts.delete('/:id', checkLoggedIn, postsCtrl.checkObjectId, postsCtrl.remove);
posts.patch('/:id', checkLoggedIn, postsCtrl.checkObjectId, postsCtrl.update);

export default posts;

[포스트 작성 시 사용자 정보 넣기]
- checkLoggedIn 미들웨어를 통해 로그인된 사용자만 포스트를 작성할 수 있게 설정을 했으니, 지금부터는 포스트를 작성할 때 사용자
정보를 넣어서 데이터베이스에 저장하도록 구현하다.
- src/api/posts/posts.ctrl.js
POST /api/posts
{
  title: '제목',
  body: '내용',
  tags: ['태그1', '태그2']
}
*/
export const write = async (ctx) => {
  const schema = Joi.object().keys({
    // 객체가 다음 필드를 가지고 있음을 검증
    title: Joi.string().required(), // required()가 있으면 필수 항목
    body: Joi.string().required(),
    tags: Joi.array().items(Joi.string()).required(), // 문자열로 이루어진 배열
  });
  // 검증하고 나서 검증 실패인 경우 에러 처리
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400; // Bad Request
    ctx.body = result.error;
    return;
  }

  const { title, body, tags } = ctx.request.body;
  const post = new Post({
    title,
    body,
    tags,
    user: ctx.state.user,
  });
  try {
    await post.save();
    ctx.body = post;
  } catch (e) {
    ctx.throw(500, e);
  }
};

[포스트 수정 및 삭제 시 권한 확인하기]
- 작성자만 포스트를 수정하거나 삭제할 수 있도록 구현한다. 이 작업을 미들웨어에서 처리하고 싶다면 id로 포스트를 조회하는 작업도
미들웨어로 해 주어야 한다.
- 따라서 기존에 만들었던 checkObjectId를 getPostById로 바꾸고, 해당 미들웨어에서 id로 포스트를 찾은 후 ctx.state에 담아 준다.
- src/api/posts/posts.ctrl.js
export const getPostById = async (ctx, next) => {
  const { id } = ctx.params;
  if (!ObjectId.isValid(id)) {
    ctx.status = 400; // Bad Request
    return;
  }
  try {
    const post = await Post.findById(id);
    if (!post) {
      ctx.status = 404;
      return;
    }
    ctx.state.post = post;
    return next();
  } catch (e) {
    ctx.throw(500, e);
  }
};
- 작성 후 미들웨어를 posts 라우터에 적용한다.
- src/api/posts/index.js
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';
import checkLoggedIn from '../../lib/checkLoggedIn';
const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', checkLoggedIn, postsCtrl.write);
posts.get('/:id', postsCtrl.getPostById, postsCtrl.read); // ObjectId를 검증해주는 미들웨어 추가
posts.delete(
  '/:id',
  checkLoggedIn,
  postsCtrl.getPostById,
  postsCtrl.remove,
);
posts.patch(
  '/:id',
  checkLoggedIn,
  postsCtrl.getPostById,
  postsCtrl.update,
);

export default posts;

- getPostById에서 ObjectId 형식이 올바른지 확인할 뿐만 아니라 post 정보를 데이터베이스로 부터 받아와 ctx.state에 담기 때문에
read API를 간소화 해준다.
/* 특정 포스트 조회
GET /api/posts/:id
*/
export const read = async (ctx) => {
  ctx.body = ctx.state.post;
};

- getPostById를 구현하고 적용했다면 이번에는 checkOwnPost라는 미들웨어를 작성한다. 이 미들웨어는 id로 찾은 포스트가
로그인 중인 사용자가 작성한 포스트인지 확인해준다.
- 만약 사용자의 포스트가 아니라면 403 에러를 발생시킨다.
- src/api/posts/posts.ctrl.js
export const checkOwnPost = (ctx, next) => {
  const { user, post } = ctx.state;
  if (post.user._id.toString() !== user._id) {
    ctx.status = 403;
    return;
  }
  return next();
};
- MongoDB에서 조회한 데이터의 id 값을 문자열과 비교할 때는 반드시 .toString()을 해주어야 한다.
- 이 미들웨어를 수정 및 삭제 API에 적용한다.
- src/api/posts/index.js
import Router from 'koa-router';
import * as postsCtrl from './posts.ctrl';
import checkLoggedIn from '../../lib/checkLoggedIn';
const posts = new Router();

posts.get('/', postsCtrl.list);
posts.post('/', checkLoggedIn, postsCtrl.write);
posts.get('/:id', postsCtrl.getPostById, postsCtrl.read); // ObjectId를 검증해주는 미들웨어 추가
posts.delete(
  '/:id',
  checkLoggedIn,
  postsCtrl.getPostById,
  postsCtrl.checkOwnPost,
  postsCtrl.remove,
);
posts.patch(
  '/:id',
  checkLoggedIn,
  postsCtrl.getPostById,
  postsCtrl.checkOwnPost,
  postsCtrl.update,
);

export default posts;
- 이렇게 설정하면 다른 계정으로 작성된 포스트를 삭제하려고 하면 403 Forbidden 에러가 발생한다.

username/tags로 포스트 필터링하기
- 이번에는 특정 사용자가 작성한 포스트만 조회하거나 특정 태그가 있는 포스트만 조회하는 기능을 구현한다.
- 그럴려면 포스트 목록 조회 API를 수정해야 한다.
/* 포스트 조회
GET /api/posts?username=&tag=&page=
*/
export const list = async (ctx) => {
  // query는 문자열이기 때문에 숫자로 변환해 주어야 한다.
  // 값이 주어지지 않았다면 1을 기본으로 사용합니다.
  const page = parseInt(ctx.query.page || '1', 10);

  if (page < 1) {
    ctx.status = 400;
    return;
  }

  const { tag, username } = ctx.query;
  const query = {
    ...(username ? { 'user.username': username } : {}),
    ...(tag ? { tags: tag } : {}),
  };

  try {
    const posts = await Post.find(query)
      .sort({ _id: -1 })
      .limit(10)
      .skip((page - 1) * 10)
      .exec();
    const postCount = await Post.countDocuments(query).exec();
    ctx.set('Last-Page', Math.ceil(postCount / 10));
    ctx.body = posts
      .map((post) => post.toJSON())
      .map((post) => ({
        ...post,
        body:
          post.body.length < 200 ? post.body : `${post.body.slice(0, 200)}...`,
      }));
  } catch (e) {
    ctx.throw(500, e);
  }
};

- 위 코드에서 query를 선언하는 방법이 조금 생소하다. (ㄹㅇ)
- 이 코드는 username 혹은 tag 값이 유효할 때만 객체 안에 해당 값을 넣겠다는 것을 의미한다.
- 다음과 같은 형식으로 query 객체를 만들면 어떻게 될까?
{
  username,
  tags: tag,
}
- 이러 객체를 query로 사용한다면 요청을 받을 때 username이나 tag값이 주어지지 않는다면 undefined 값이 들어가게 된다.
- mongoose는 특정 필드가 undefined인 데이터를 찾게 되고, 결국 데이터를 조회할 수 없다.
- 코드를 다 작성했으면 URL에 username, tag 쿼리 파라미터를 포함시켜서 API를 요청해보자
